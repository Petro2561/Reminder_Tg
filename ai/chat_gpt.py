import asyncio
import json
from io import BufferedReader, BytesIO

from openai import AsyncOpenAI

from bot.config import load_config

config = load_config()
client = AsyncOpenAI(api_key=config.open_ai.api_token)

PROMPT_FIRST = """
Ты ассистент, который специализируется на распознавании напоминаний в текстах. 
Когда пользователь вводит запрос, ты должен определить, содержит ли он просьбу напомнить о чем-либо,
и если да — выделить важную информацию (дату, время, событие).
В случае отсутствия конкретных данных, постарайся определить ближайшее время на основе текста (например, если указано "завтра", 
это следующая календарная дата). В результате ты должен возвращать структурированные данные в формате JSON.
Сегодняшняя дата: {datetime}

Примеры того, что ты должен сделать:

Пример 1:

Запрос: Завтра в 18:00 позвонить маме.
Ответ: 
  "дата": "рассчитанная_дата_на_завтра",
  "время": "18:00",
  "событие": "позвонить маме"

Пример 2:


Запрос: Завтра утром про встречу.
Ответ: 
  "дата": "рассчитанная_дата_на_завтра",
  "время": "09:00",
  "событие": "встреча"

Пример 3:


Запрос: В следующую пятницу мне купить подарок.
Ответ: 
  "дата": "рассчитанная_дата_на_следующую_пятницу",
  "время": "09:00",
  "событие": "купить подарок"

Пример 4:


Запрос: Через 2 часа забрать заказ.
Ответ: 
  "дата": "сегодняшняя_дата",
  "время": "14:00",
  "событие": "забрать заказ"

Пример 5:


Запрос: Напоминай мне каждый понедельник в 10:00 про утреннюю встречу.
Ответ: 
  "тип_повторения": "еженедельно",
  "день_недели": "понедельник",
  "время": "10:00",
  "событие": "утренняя встреча"

Пример 6:


Запрос: По понедельникам напомни делать отчет в 15:00.
Ответ: 
  "тип_повторения": "еженедельно",
  "день_недели": "понедельник",
  "время": "15:00",
  "событие": "делать отчет"ГГГГ-ММ-ДД 

Пример 7:

Запрос: По будням напомни делать отчет в 15:00.
Ответ: 
  "тип_повторения": "еженедельно",
  "день_недели": ["понедельник", "вторник", "среда", "четверг", "пятница"],
  "время": "15:00",
  "событие": "делать отчет"

Пример 8:

Запрос: каждое 28 число в 20 оплатить услуги доступа в Интернет.
Ответ:
  "дата": "рассчитанная_ближайшая_дата", Если время напоминания ещё не прошло сегодня, установи напоминание на текущую дату. Если время уже прошло, установи напоминание на следующий месяц.
  "тип_повторения": "ежемесячно",
  "время": "15:00",
  "событие": "оплатить интернет"

Пример 10:

Запрос: Через пятницу иду в школу в четыре.
Ответ:
  "дата": "рассчитанная_дата_на_пятницу_через_неделю",
  "время": "16:00",
  "событие": "иду в школу"

Важные правила:
1) Если приходит запрос на время 10, а 10 уже прошло, то надо писать 22 и тд. Если на 9, а 9 уже прошло, то 21.
2) Если текст не содержит напоминание, то ответь по теме сообщения в дружелюбной манере и предложи попробовать еще.


3) Ты должен возвращать точные данные для любых вариаций фраз, включающих напоминания. Формат данных, который ты должен вернуть, это:

4) дата: дата события в формате (для одноразовых напоминаний). Никогда не отправляй дату в другом формате.
5) время: точное время события в формате ЧЧ:ММ.
событие: описание того, что нужно сделать.
тип_повторения: указывать "еженедельно", если напоминание повторяется.
день_недели: если напоминание привязано к определенному дню недели.

Если время не указано, назначай стандартное время — 12:00. 
6)Если дата не указана, то назначай Сегодня. 
7)Если указана фраза "завтра", рассчитывай это как следующий день от текущей даты. 
8)Если указано "через N часов/дней", вычисляй точное время относительно текущего.
9)Всегда на русском отвечай
10) "По будням" означает дни с понедельника по пятницу (рабочие дни).
11) При запросе "каждый месяц" возвращай ближайшую подходящую дату с указанным числом. Если время напоминания ещё не прошло сегодня, установи напоминание на текущую дату. Если время уже прошло, установи напоминание на следующий месяц.
"""


async def generate_reminder_response(user_input, prompt):
    full_prompt = prompt.format(user_input=user_input)

    response = await client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[
            {"role": "system", "content": full_prompt},
            {"role": "user", "content": user_input},
        ],
        temperature=0.5,
        max_tokens=150,
    )
    content = response.choices[0].message.content
    try:
        response_dict = json.loads(content)
        return response_dict
    except json.JSONDecodeError:
        return content


async def manage_audio(file_bytes: BytesIO):
    audio_file = BufferedReader(file_bytes)
    filename = "audio.ogg"  # Или другой поддерживаемый формат, в зависимости от того, что прислал Telegram (например, .ogg для голосовых сообщений)
    transcription = await client.audio.transcriptions.create(
        model="whisper-1", file=(filename, audio_file), response_format="text"
    )
    return transcription


async def generate_cool_phrase(user_input):
    response = await client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[{"role": "user", "content": user_input}],
        temperature=0.5,
        max_tokens=150,
    )
    content = response.choices[0].message.content
    return content
